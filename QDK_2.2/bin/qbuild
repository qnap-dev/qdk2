#!/bin/bash
##############################################################################
#
# $Id: qbuild 357 2011-03-14 09:37:25Z micke $
#
# This script is used to build QPKGs.
#
# Copyright (c) 2010,2011  Michael Nordstrom
#
# Information about required tail data is retrieved from QNAP's build
# script, qpkg_build_QNAP.sh, Copyright (C) 2008 QNAP Systems, Inc.
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
#
##############################################################################

# Cleanup any temporary directories and files at termination.
trap 'cleanup_all' INT TERM

QDK_PATH=/usr/share/qdk2/QDK

# Check for deprecated definitions and replace them with new
# definitions (when applicable).
check_deprecated_definitions(){
	if [ -n "$QDK_SRC_DIR" ]; then
		[ -z "$QDK_ROOT_DIR" ] && QDK_ROOT_DIR="$QDK_SRC_DIR"
		QDK_SRC_DIR=
		warn_msg "QDK_SRC_DIR: deprecated definition"
	fi
	if [ -n "$QDK_SRC_X09" ]; then
		[ -z "$QDK_DATA_DIR_X09" ] && QDK_DATA_DIR_X09="$QDK_SRC_X09"
		QDK_SRC_X09=
		warn_msg "QDK_SRC_X09: deprecated definition"
	fi
	if [ -n "$QDK_SRC_X19" ]; then
		[ -z "$QDK_DATA_DIR_X19" ] && QDK_DATA_DIR_X19="$QDK_SRC_X19"
		QDK_SRC_X19=
		warn_msg "QDK_SRC_X19: deprecated definition"
	fi
	if [ -n "$QDK_SRC_X86" ]; then
		[ -z "$QDK_DATA_DIR_X86" ] && QDK_DATA_DIR_X86="$QDK_SRC_X86"
		QDK_SRC_X86=
		warn_msg "QDK_SRC_X86: deprecated definition"
	fi
	if [ -n "$QDK_SRC_X86_64" ]; then
		[ -z "$QDK_DATA_DIR_X86_64" ] && QDK_DATA_DIR_X86_64="$QDK_SRC_X86_64"
		QDK_SRC_X86_64=
		warn_msg "QDK_SRC_X86_64: deprecated definition"
	fi
	if [ -n "$QDK_SRC_SHARED" ]; then
		[ -z "$QDK_DATA_DIR_SHARED" ] && QDK_DATA_DIR_SHARED="$QDK_SRC_SHARED"
		QDK_SRC_SHARED=
		warn_msg "QDK_SRC_SHARED: deprecated definition"
	fi
	if [ -n "$QDK_SRC_ICONS" ]; then
		[ -z "$QDK_DATA_DIR_ICONS" ] && QDK_DATA_DIR_ICONS="$QDK_SRC_ICONS"
		QDK_SRC_ICONS=
		warn_msg "QDK_SRC_ICONS: deprecated definition"
	fi
	if [ -n "$QDK_SRC_CONFIG" ]; then
		[ -z "$QDK_DATA_DIR_CONFIG" ] && QDK_DATA_DIR_CONFIG="$QDK_SRC_CONFIG"
		QDK_SRC_CONFIG=
		warn_msg "QDK_SRC_CONFIG: deprecated definition"
	fi
	if [ -n "$QDK_SRC_FILE" ]; then
		[ -z "$QDK_DATA_FILE" ] && QDK_DATA_FILE="$QDK_SRC_FILE"
		QDK_SRC_FILE=
		warn_msg "QDK_SRC_FILE: deprecated definition"
	fi
	if [ -f "$QDK_QPKG_CONFIG" ] && /bin/grep -q '^QPKG_CONFIG_DIR' $QDK_QPKG_CONFIG; then
		[ -n "$HAS_WARNED_CONFIG_DIR" ] || warn_msg "QPKG_CONFIG_DIR: deprecated definition"
		HAS_WARNED_CONFIG_DIR=TRUE
	fi
	if [ -f "$QDK_QPKG_CONFIG" ] && /bin/grep -q '^QDK_EXTRA_SRC_FILE' $QDK_QPKG_CONFIG; then
		[ -n "$HAS_WARNED_EXTRA_SRC_FILE" ] || warn_msg "QDK_EXTRA_SRC_FILE: deprecated definition"
		HAS_WARNED_EXTRA_SRC_FILE=TRUE
	fi
}

# Retrieve data in network byte order.
network_order_32bit(){
	[ -n "$1" ] && [ -n "$2" ] || err_msg "internal error: network_order_32bit called with missing arguments"
	local off="$1"
	local qpkg="$2"
	[ -f $qpkg ] || err_msg "$qpkg: no such file"
	local word=$(/usr/bin/hexdump -s $off -n 1 -e '1/1 "%u"' $qpkg)
	word=$((word * 256))
	off=$((off + 1))
	word=$(((word + $(/usr/bin/hexdump -s $off -n 1 -e '1/1 "%u"' $qpkg)) * 256))
	off=$((off + 1))
	word=$(((word + $(/usr/bin/hexdump -s $off -n 1 -e '1/1 "%u"' $qpkg)) * 256))
	off=$((off + 1))
	word=$((word + $(/usr/bin/hexdump -s $off -n 1 -e '1/1 "%u"' $qpkg)))
	echo "$word"
}

# Retrieve size of content (that is the size of the header, control data, data
# archive, and any optional extra data archives.)
get_content_size(){
	[ -n "$1" ] || err_msg "internal error: get_content_size called with no argument"
	local qpkg="$1"
	[ -f $qpkg ] || err_msg "$qpkg: no such file"
	local offset_command="$(/bin/sed -n "1,/^exit 1/{
s/^script_len.*/&;/p
s/^offset.*/&;/p
/^exit 1/q
}" $qpkg) echo \$offset"
	echo "$(eval $offset_command)"
}

# Supported data types in the QDK area.
readonly QDK_AREA_SIGNATURE=1
readonly QDK_AREA_EOF=255

# Length of QDK tag that is added to the front of the QDK area.
readonly QDK_AREA_TAG_LEN=3

# Length of data type value.
readonly QDK_AREA_DATA_TYPE_LEN=1

# Length of data size value.
readonly QDK_AREA_DATA_SIZE_LEN=4

# Length of tail data.
readonly TAIL_DATA_LEN=100

# Retrieve location of QDK area.
get_qdk_area_pos(){
	[ -n "$1" ] || err_msg "internal error: get_qdk_area_pos called with no argument"
	local qpkg="$1"
	[ -f $qpkg ] || err_msg "$qpkg: no such file"
	local qdk_area=$(get_content_size $qpkg)
	local qdk_string="$(/bin/dd if=$qpkg bs=$qdk_area skip=1 2>/dev/null | /bin/dd bs=$QDK_AREA_TAG_LEN count=1 2>/dev/null)"
	if [ "$qdk_string" = "QDK" ]; then
		echo "$qdk_area"
		return 0
	fi
	return 1
}

# Retrieve location of specified data type in QDK area (if found)
get_qdk_area_data_pos(){
	[ -n "$1" ] && [ -n "$2" ] || err_msg "internal error: get_qdk_area_data_pos called with missing arguments"
	local data_type="$1"
	local qpkg="$2"
	[ -f $qpkg ] || err_msg "$qpkg: no such file"
	local qdk_area=
	qdk_area=$(get_qdk_area_pos $qpkg) || return 1
	qdk_area=$(($qdk_area + $QDK_AREA_TAG_LEN))

	# Traverse QDK area looking for specified data type. Stop if reaching the end
	# of the QDK area either by finding the QDK_AREA_EOF tag or by reaching the
	# tail data.
	local qdk_area_end=$(($(/bin/ls -l $qpkg | awk '{ print $5 }') - $TAIL_DATA_LEN))
	local qdk_size=
	local qdk_pos=$qdk_area
	local qdk_type=$(/usr/bin/hexdump -s $qdk_area -n $QDK_AREA_DATA_TYPE_LEN -e '1/1 "%d"' $qpkg)
	while [ $qdk_type -ne $data_type ] && [ $qdk_type -ne $QDK_AREA_EOF ] && (( $qdk_area <= $qdk_area_end ))
	do
		qdk_area=$(($qdk_area + $QDK_AREA_DATA_TYPE_LEN))
		qdk_size=$(network_order_32bit $qdk_area $qpkg)
		qdk_area=$(($qdk_area + $qdk_size + $QDK_AREA_DATA_SIZE_LEN))
		qdk_pos=$qdk_area
		qdk_type=$(/usr/bin/hexdump -s $qdk_area -n $QDK_AREA_DATA_TYPE_LEN -e '1/1 "%d"' $qpkg)
	done
	if (( $qdk_type == $data_type )); then
		echo "$qdk_pos"
		return 0
	fi
	return 1
}

# Retrieve location of signature (if found)
get_signature_pos(){
	[ -n "$1" ] || err_msg "internal error: get_signature_pos called with no argument"
	local qpkg="$1"
	[ -f $qpkg ] || err_msg "$qpkg: no such file"
	local qdk_pos=
	qdk_pos=$(get_qdk_area_data_pos $QDK_AREA_SIGNATURE $qpkg) || return 1

	# The signature is located after the data type and size data.
	echo "$(($qdk_pos + $QDK_AREA_DATA_TYPE_LEN + $QDK_AREA_DATA_SIZE_LEN))"
}

# Retrieve size of signature (if found)
get_signature_len(){
	[ -n "$1" ] || err_msg "internal error: get_signature_len called with no argument"
	local qpkg="$1"
	[ -f $qpkg ] || err_msg "$qpkg: no such file"
	local qdk_pos=
	qdk_pos=$(get_qdk_area_data_pos $QDK_AREA_SIGNATURE $qpkg) || return 1
	qdk_pos=$(($qdk_pos + $QDK_AREA_DATA_TYPE_LEN))

	echo "$(network_order_32bit $qdk_pos $qpkg)"
}

# Add given architecture to comma-separated list in QDK_BUILD_ARCH.
add_arch(){
	debug_msg "Adding $1 to list of architectures"
	[ -n "$1" ] && QDK_BUILD_ARCH="${QDK_BUILD_ARCH}${QDK_BUILD_ARCH:+,}$1"
}

# Error messages are always printed (to stderr) before the application
# removes any temporary files and exit (in cleanup_all).
err_msg(){
	echo "$1" 1>&2
	cleanup_all
}

# Warning messages are printed (to stderr) but won't exit the application
# unless running in strict mode.
warn_msg(){
	if [ "$QDK_STRICT" = "TRUE" ]; then
		err_msg "$1"
	else
		msg "$1" 1>&2
	fi
}

# Verbosity levels
readonly QUIET=0
readonly NORMAL=1
readonly VERBOSE=2
readonly DEBUG=3

# Set to no messages.
is_quiet(){
	(( $QDK_VERBOSE == $QUIET )) || return 1
}

# Set to verbose or debug messages.
is_verbose(){
	(( $VERBOSE <= $QDK_VERBOSE )) || return 1
}

# Set to debug messages.
is_debug(){
	(( $DEBUG <= $QDK_VERBOSE )) || return 1
}

# Log messages are printed (to stdout) if verbose mode is greater or equal
# to specified level (default: NORMAL).
msg(){
	(( ${2:-$NORMAL} <= $QDK_VERBOSE )) && echo "$1" || return 0
}
verbose_msg(){
	msg "$1" $VERBOSE
}
debug_msg(){
	msg "$1" $DEBUG
}

# Return 0 if given directory is empty, otherwise return 1
is_empty_dir(){
	[ -z "$(/bin/ls -A "$1" 2>/dev/null)" ]
}

# Set the specified field to given value and write it to the QPKG
# configuration file.
edit_qpkg_config(){
	local field="$1"
	local value="$2"
	local qpkg_cfg="${3:-$QDK_QPKG_CONFIG}"
	if [ -n "$field" ] && [ -n "$value" ] && [ -f "$qpkg_cfg" ]; then
		debug_msg "Setting $field to $value in $qpkg_cfg"
		/bin/sed -i "s/${field}=\".*\"/${field}=\"${value}\"/" "$qpkg_cfg"
		eval $field=\"$value\"
	else
		return 1
	fi
}

# Remove all temporary directories and files created by application.
cleanup_all(){
	/bin/rm -fr build.$$ tmp.$$
	/bin/rm -f $QDK_QPKG_FILE
	exit 1
}

# Sanity check of QDK environment.
sanity_check_qdk_environment(){
	[ -n "$QDK_PATH" ] || err_msg "no QDK_PATH specified in /etc/config/qdk.conf"

	QDK_SCRIPTS_DIR="${QDK_SCRIPTS_DIR:-${QDK_PATH}/scripts}"
	QDK_TEMPLATE_DIR="${QDK_TEMPLATE_DIR:-${QDK_PATH}/template}"

	QDK_INSTALL_SCRIPT="${QDK_INSTALL_SCRIPT:-${QDK_SCRIPTS_DIR}/qinstall.sh}"

	[ -x "$QDK_INSTALL_SCRIPT" ] || err_msg "$QDK_INSTALL_SCRIPT: no such file"
	[ -d "$QDK_TEMPLATE_DIR" ] || err_msg "$QDK_TEMPLATE_DIR: no such directory"
	[ -f "${QDK_TEMPLATE_DIR}/package_routines" ] || err_msg "${QDK_TEMPLATE_DIR}/package_routines: no such file"
	[ -f "${QDK_TEMPLATE_DIR}/qpkg.cfg" ] || err_msg "${QDK_TEMPLATE_DIR}/qpkg.cfg: no such file"
	QDK_MD5SUM_APP="${QDK_MD5SUM_APP:-$(command -v md5sum)}"
	[ -x "$QDK_MD5SUM_APP" ] || err_msg "md5sum application: not found"
}

# Copy files to data package directory (with optional exclude)
sync_files(){
	local opts="$1"
	local dir="$2"
	local copy_cmd="/usr/bin/rsync $opts ${dir}/. build.$$/ 2>/dev/null"
	debug_msg "$copy_cmd"
	eval $copy_cmd
}

# Copy configuration files to data package directory
copy_config(){
	local file="$1"
	local copy_cmd="/bin/cp -pf ${QDK_DATA_DIR_CONFIG:-config}/$file build.$$/"
	debug_msg "$copy_cmd"
	eval $copy_cmd
}

# Copy icons to data package directory
copy_icons(){
	local src_name="$1"
	local dest_name="$2"
	local copy_cmd="/bin/cp -pf ${QDK_DATA_DIR_ICONS:-icons}/$src_name build.$$/$dest_name"
	debug_msg "$copy_cmd"
	eval $copy_cmd
}

# Add architecture files to data package directory
add_architecture_files(){
	local rsync_opts="$1"
	local arch_dir="$2"

	if [ -d "$arch_dir" ]; then
		verbose_msg "Adding architecture specific files..."

		is_empty_dir "$arch_dir" && warn_msg "$arch_dir: empty directory"
		sync_files "$rsync_opts" "$arch_dir"
	fi
}

# Add shared files to data package directory
add_shared_files(){
	verbose_msg "Adding shared files..."

	local rsync_opts="$1"
	is_empty_dir "${QDK_DATA_DIR_SHARED:-shared}" || sync_files "$rsync_opts" "${QDK_DATA_DIR_SHARED:-shared}"
}

# Add any package icons (only includes icons using correct names)
add_icons(){
	verbose_msg "Adding icons..."

	local dist_icons="${QDK_DATA_DIR_ICONS:-icons}"
	if [ -d "$dist_icons" ]; then
		[ -f "${dist_icons}/${QPKG_NAME}.gif" ] && copy_icons "${QPKG_NAME}.gif" .qpkg_icon.gif
		[ -f "${dist_icons}/${QPKG_NAME}_80.gif" ] && copy_icons "${QPKG_NAME}_80.gif" .qpkg_icon_80.gif
		[ -f "${dist_icons}/${QPKG_NAME}_gray.gif" ] && copy_icons "${QPKG_NAME}_gray.gif" .qpkg_icon_gray.gif
	fi
}

# Add config files to data package directory
add_config_data(){
	verbose_msg "Adding configuration files..."

	local md5sum=
	local qpkg_config=$(/bin/sed -n '/^QPKG_CONFIG/s/QPKG_CONFIG="\(.*\)"/\1/p' $QDK_QPKG_CONFIG)
	for file in $qpkg_config
	do
		debug_msg "    $file"
		# Configuration files relative to QPKG directory.
		if [ -n "${file##/*}" ]; then
			[ -f "${QDK_DATA_DIR_CONFIG:-config}/$file" ] && copy_config "$file"
			if [ -f "build.$$/$file" ]; then
				md5sum=$($QDK_MD5SUM_APP "build.$$/$file" 2>/dev/null | /bin/cut -d' ' -f1)
				echo "$file = $md5sum" >> tmp.$$/md5sum
			elif [ "$QDK_FORCE_CONFIG" = "TRUE" ]; then
				echo "$file = 0" >> tmp.$$/md5sum
			else
				err_msg "$file: no such file; check your QPKG_CONFIG settings"
			fi
		else # Absolute path configuration files.
			if [ -f "${QDK_DATA_DIR_CONFIG:-config}/${file#*/}" ]; then
				/bin/tar rf tmp.$$/conf.tar -C "${QDK_DATA_DIR_CONFIG:-config}" "./${file#*/}"
				md5sum=$($QDK_MD5SUM_APP "${QDK_DATA_DIR_CONFIG:-config}/${file#*/}" 2>/dev/null | /bin/cut -d' ' -f1)
				echo "$file = $md5sum" >> tmp.$$/md5sum
			elif [ "$QDK_FORCE_CONFIG" = "TRUE" ]; then
				echo "$file = 0" >> tmp.$$/md5sum
			else
				err_msg "$file: no such file; check your QPKG_CONFIG settings"
			fi
		fi
	done
	[ -f tmp.$$/conf.tar ] && /bin/gzip -9 tmp.$$/conf.tar
}

# Create data package for distribution.
create_data_package(){
	local arch_msg="${1:+ for $1}"
	local arch_dir="$2"
    local BUILD_DIR=build.$$
    local TMP_DIR=tmp.$$

	msg "Creating archive with data files${arch_msg}..."

	/bin/mkdir -m 755 -p build.$$ || err_msg "failed to create directory for data files"

	local rsync_opts="-av"
	is_debug || rsync_opts="$rsync_opts -q"
	[ -z "$QDK_RSYNC_EXCLUDE" ] || rsync_opts="$rsync_opts $QDK_RSYNC_EXCLUDE"
	[ -z "$QDK_RSYNC_EXCLUDE_FROM" ] || rsync_opts="$rsync_opts $QDK_RSYNC_EXCLUDE_FROM"
	add_shared_files "$rsync_opts"
	add_architecture_files "$rsync_opts" "$arch_dir"
	add_icons
	add_config_data

	verbose_msg "Creating compressed tar archive..."
	case "$QDK_COMPRESS_METHOD" in
	gzip)
		QDK_COMPRESS_FILE=data.tar.gz
		debug_msg "[$QDK_COMPRESS_FILE]"
        local SIZE=$(du -sb "${BUILD_DIR}" | grep -o '^[0-9]\+')
        debug_msg "$(tar cf - -C ${BUILD_DIR} . | pv -s $SIZE -N tar | gzip > ${TMP_DIR}/data.tar.gz)"
		;;
	bzip2)
		QDK_COMPRESS_FILE=data.tar.bz2
		debug_msg "[$QDK_COMPRESS_FILE]"
		debug_msg "$(/bin/tar -cvjf tmp.$$/data.tar.bz2 -C build.$$ .)"
		;;
	7zip)
		QDK_COMPRESS_FILE=data.tar.7z
		local tar_verbose=
		is_debug && tar_verbose="-v"
		debug_msg "[$QDK_COMPRESS_FILE]"
		debug_msg "$(/bin/tar $tar_verbose -cf - -C build.$$ . | /usr/local/sbin/7z a -si tmp.$$/data.tar.7z)"
		;;
	xz)
		QDK_COMPRESS_FILE=data.tar.xz
		debug_msg "[$QDK_COMPRESS_FILE]"
        local SIZE=$(du -sb "${BUILD_DIR}" | grep -o '^[0-9]\+')
        debug_msg "$(tar cf - -C ${BUILD_DIR} . | pv -s $SIZE -N tar | xz > ${TMP_DIR}/${QDK_COMPRESS_FILE})"
		;;
	*)
		err_msg "$QDK_COMPRESS_METHOD: unknown compression format"
	esac
	/bin/rm -fr build.$$
}

create_control_package(){
	msg "Creating archive with control files..."

	/bin/mkdir -m 755 -p build.$$ || err_msg "failed to create directory for control files"

	/bin/cp -p "$QDK_INSTALL_SCRIPT" build.$$/
	/bin/cp -p "$QDK_PACKAGE_ROUTINES" build.$$/package_routines
	/bin/cp -p "$QDK_QPKG_CONFIG" build.$$/qpkg.cfg
    # xz utility
    if [ "$QDK_COMPRESS_METHOD" == "xz" ]; then
        /bin/cp $(dirname $(dirname $(realpath $0)))/xz_1404_${QDK_XZ_ARCH}.tgz build.$$/xz.tgz
    fi

	[ -f tmp.$$/md5sum ] && /bin/cp -p tmp.$$/md5sum build.$$/
	[ -f tmp.$$/conf.tar.gz ] && /bin/cp -p tmp.$$/conf.tar.gz build.$$/

	debug_msg "$(/bin/tar -cvzf tmp.$$/${QDK_CONTROL_FILE}.gz -C build.$$ .)"
	/bin/tar -cf tmp.$$/$QDK_CONTROL_FILE -C tmp.$$ ${QDK_CONTROL_FILE}.gz
	/bin/rm -fr build.$$
	/bin/rm -f tmp.$$/${QDK_CONTROL_FILE}.gz
	/bin/rm -f tmp.$$/conf.tar.gz
	/bin/rm -f tmp.$$/md5sum
}

# Include any optional Optware packages.
create_packages_file(){
	local opt_files="$(/bin/sed -n \
		-e '/^QDK_EXTRA_SRC_FILE/s/QDK_EXTRA_SRC_FILE="\(.*\.[io]pk\)"/\1/p' \
		-e '/^QDK_EXTRA_FILE/s/QDK_EXTRA_FILE="\(.*\.[io]pk\)"/\1/p' $QDK_QPKG_CONFIG)"
	for file in $opt_files
	do
		verbose_msg "Add $file to Packages"
		[ -f $file ] || err_msg "$file: no such file"
		/bin/tar -xOf $file ./control.tar.gz | /bin/tar xzO ./control | /bin/sed -e '/Priority.*/d' -e '/.*: $/d' >> tmp.$$/Packages || warn_msg "$file: missing control file"
		echo "Filename: ${file##*/} " >> tmp.$$/Packages
		echo "MD5Sum: $($QDK_MD5SUM_APP $file | awk '{ print $1 }')" >> tmp.$$/Packages
		echo "Size: $(/bin/ls -l $file | awk '{ print $5 }')" >> tmp.$$/Packages
		printf "\n\n" >> tmp.$$/Packages
	done
	if [ -f tmp.$$/Packages ]; then
		is_debug && /bin/cat tmp.$$/Packages
		/bin/gzip tmp.$$/Packages
	fi
}

# Pad given field with spaces up to optional given maximum length (default is 10)
pad_field(){
	[ -n "$1" ] || err_msg "internal error: pad_field called with no argument"

	local field="$1"
	local field_val=
	eval "field_val=\$$field"
	local pad_len=$((${2:-10} - ${#field_val}))

	(( 0 <= $pad_len )) || err_msg "the length of $field_val must be less than or equal to ${2:-10}"
	while (( 0 < $pad_len ))
	do
		field_val="$field_val "
		pad_len=$(($pad_len - 1))
	done
	eval $field=\""$field_val"\"
}

# Add QPKG header (initial extract script).
add_qpkg_header(){
	local arch="$1"

	verbose_msg "Adding header script..."

	# Return value 0 to keep the QPKG package after installation
	# Return value 10 to remove QPKG package after installation
	local retval=10
	local extract_dir="\$QPKG_INSTALL_PATH/.tmp"
	local wrong_arch="Wrong architecture: $QPKG_NAME $QPKG_VER is built for $arch"
	local log_tool="/sbin/log_tool -t2 -uSystem -p127.0.0.1 -mlocalhost -a"

	local cpu_arch=
	case "$arch" in
		arm-x09)
			cpu_arch="armv5tejl"
			;;
		arm-x19)
			cpu_arch="armv5tel"
			;;
		x86)
			cpu_arch="i.86\|x86_64"
			;;
		x86_64)
			cpu_arch="x86_64"
			;;
		*)
			cpu_arch=
			;;
	esac

	echo "#!/bin/sh" > $QDK_QPKG_FILE
    /bin/cat >>$QDK_QPKG_FILE <<-EOF
    find_base(){
            if [ -z "\$QINSTALL_PATH" ]; then
                BASE_GROUP="/share/HDA_DATA /share/HDB_DATA /share/HDC_DATA /share/HDD_DATA /share/HDE_DATA /share/HDF_DATA /share/HDG_DATA /share/HDH_DATA /share/HDI_DATA /share/HDJ_DATA /share/HDK_DATA /share/HDL_DATA /share/MD0_DATA /share/MD1_DATA /share/MD2_DATA /share/MD3_DATA"
                publicdir=\`/sbin/getcfg Public path -f /etc/config/smb.conf\`
                if [ ! -z \$publicdir ] && [ -d \$publicdir ];then
                        publicdirp1=\`/bin/echo \$publicdir | /bin/cut -d "/" -f 2\`
                        publicdirp2=\`/bin/echo \$publicdir | /bin/cut -d "/" -f 3\`
                        publicdirp3=\`/bin/echo \$publicdir | /bin/cut -d "/" -f 4\`
                        if [ ! -z \$publicdirp1 ] && [ ! -z \$publicdirp2 ] && [ ! -z \$publicdirp3 ]; then
                                [ -d "/\${publicdirp1}/\${publicdirp2}/Public" ] && QPKG_BASE="/\${publicdirp1}/\${publicdirp2}"
                        fi
                fi

                # Determine BASE installation location by checking where the Public folder is.
                if [ -z \$QPKG_BASE ]; then
                        for datadirtest in \$BASE_GROUP; do
                        [ -d \$datadirtest/Public ] && QPKG_BASE="/\${publicdirp1}/\${publicdirp2}"
                        done
                fi
                if [ -z \$QPKG_BASE ] ; then
                        echo "The Public share not found."
                        return 1
                fi
                QPKG_INSTALL_PATH="\${QPKG_BASE}/.qpkg"
                QPKG_DIR="\${QPKG_INSTALL_PATH}/\${QPKG_NAME}"
            else
                QPKG_INSTALL_PATH="\${QINSTALL_PATH}"
                QPKG_DIR="\${QINSTALL_PATH}/\${QPKG_NAME}"
            fi
            return 0
    }
	EOF

	if [ -n "$cpu_arch" ]; then
        /bin/cat >>$QDK_QPKG_FILE <<-EOF
		wrong_arch(){
			 local wrong_arch_msg="$wrong_arch"
			 echo "Installation Abort." && echo "\$wrong_arch_msg"
			 $log_tool "\$wrong_arch_msg"
			 echo -1 > /tmp/update_process && exit 1
		}
		arch_ok(){
			 local cpu_arch=\$(/bin/uname -m)
			 [ \$(/usr/bin/expr match "\$cpu_arch" "$cpu_arch") -ne 0 ] || return 1
		}
		EOF
	fi

	/bin/cat >>$QDK_QPKG_FILE <<-EOF
	/bin/echo "Install QNAP package on TS-NAS..."
	/bin/grep "/mnt/HDA_ROOT" /proc/mounts >/dev/null 2>&1 || exit 1
	EOF
	if [ -n "$cpu_arch" ]; then
		echo "arch_ok || wrong_arch" >>$QDK_QPKG_FILE
	fi

	local ctrl_len=$(/bin/ls -l tmp.$$/$QDK_CONTROL_FILE | awk '{ print $5 }')
	local data_len=$(/bin/ls -l tmp.$$/$QDK_COMPRESS_FILE | awk '{ print $5 }')
	[ -f tmp.$$/extra.tar ] && local extra_len=$(/bin/ls -l tmp.$$/extra.tar | awk '{ print $5 }')

	/bin/cat >>$QDK_QPKG_FILE <<-EOF
    find_base
	_EXTRACT_DIR="$extract_dir"
	/bin/mkdir -p \$_EXTRACT_DIR || exit 1
	script_len=SCRIPT_LEN
	/bin/dd if=\${0} bs=\$script_len skip=1 | /bin/tar -xO | /bin/tar -xzv -C \$_EXTRACT_DIR || exit 1
	offset=\$(/usr/bin/expr \$script_len + $ctrl_len)
	/bin/dd if=\${0} bs=\$offset skip=1 | /bin/cat | /bin/dd bs=1024 count=$((($data_len + 1023) / 1024)) of=\$_EXTRACT_DIR/$QDK_COMPRESS_FILE || exit 1
	[ -f /usr/local/bin/python ] && /usr/local/bin/python -c "with open('$QDK_COMPRESS_FILE', 'rw+') as f: f.seek($data_len); f.truncate()â€
	offset=\$(/usr/bin/expr \$offset + $data_len)
	EOF

	# Extract any optional extra data packages.
	if /bin/grep -q '^QDK_EXTRA_FILE\|^QDK_EXTRA_SRC_FILE' $QDK_QPKG_CONFIG; then
		echo "/bin/dd if=\${0} bs=\$offset skip=1 | /bin/tar -xv -C \$_EXTRACT_DIR || exit 1" >>$QDK_QPKG_FILE
		echo "offset=\$(/usr/bin/expr \$offset + $extra_len)" >> $QDK_QPKG_FILE
	fi

	/bin/cat >>$QDK_QPKG_FILE <<-EOF
	( cd \$_EXTRACT_DIR && /bin/sh ${QDK_INSTALL_SCRIPT##*/} || echo "Installation Abort." )
	/bin/rm -fr \$_EXTRACT_DIR && exit $retval
	exit 1
	EOF

	# Calculate header size (add 1 if number of digits in length will
	# increase the total size).
	# -10 is for the length of the placeholder, SCRIPT_LEN
	local script_len=$(($(/bin/ls -l $QDK_QPKG_FILE | awk '{ print $5 }') - 10))
	local num_of_digits_in_script_len=${#script_len}
	script_len=$(($script_len + ${#script_len}))
	if (( $num_of_digits_in_script_len < ${#script_len} )); then
		script_len=$(($script_len + 1))
	fi
	/bin/sed -i "s/SCRIPT_LEN/$script_len/" $QDK_QPKG_FILE
	is_debug && /bin/cat $QDK_QPKG_FILE
}

# Add actual content to QPKG.
add_qpkg_content(){
	verbose_msg "Adding content..."

	verbose_msg "    control data..."
	/bin/cat tmp.$$/$QDK_CONTROL_FILE >> $QDK_QPKG_FILE

	verbose_msg "    data archive..."
	/bin/cat tmp.$$/$QDK_COMPRESS_FILE >> $QDK_QPKG_FILE

	if [ -f tmp.$$/extra.tar ]; then
		verbose_msg "    extra data archives..."
		/bin/cat tmp.$$/extra.tar >> $QDK_QPKG_FILE
	fi

	/bin/rm -f tmp.$$/extra.tar tmp.$$/Packages.gz tmp.$$/$QDK_COMPRESS_FILE tmp.$$/$QDK_CONTROL_FILE
}

# Add begin tag to QDK area.
add_qdk_area_begin(){
	local qpkg="${1:-$QDK_QPKG_FILE}"
	debug_msg "QDK area begins"
	printf "QDK" >> $qpkg
}

# Add data type tag to QDK area.
add_qdk_area_data_type(){
	[ -n "$1" ] || err_msg "internal error: add_qdk_area_data_type called with no argument"
	local qpkg="${2:-$QDK_QPKG_FILE}"
	debug_msg "Data type: $1"
	printf "\\$(printf "%o" $1)" >> $qpkg
}

# Add data size to QDK area.
add_qdk_area_data_size(){
	[ -n "$1" ] || err_msg "internal error: add_qdk_area_data_size called with no argument"
	local size="$1"
	local qpkg="${2:-$QDK_QPKG_FILE}"
	printf -v size "%08x" "$size"
	debug_msg "Data size: $size"
	for byte in $(echo $size | /bin/sed 's/../& /g')
	do
		printf "\\$(printf "%o" 0x$byte)" >> $qpkg
	done
}

# Add signature data to QDK area.
add_qdk_area_signature(){
	[ -n "$1" ] || err_msg "internal error: add_qdk_area_signature called with no argument"
	local data="$1"
	local qpkg="${2:-$QDK_QPKG_FILE}"
	local size="$(/bin/ls -l $data | awk '{ print $5 }')"
	add_qdk_area_data_type $QDK_AREA_SIGNATURE $qpkg
	add_qdk_area_data_size $size $qpkg
	debug_msg "Data: $data"
	/bin/cat $data >> $qpkg
}

# Add end tag to QDK area.
add_qdk_area_end(){
	add_qdk_area_data_type $QDK_AREA_EOF $1
	debug_msg "QDK area ends"
}

# Add signature to QPKG.
add_qpkg_signature(){
	if [ "$QDK_SIGN" = "TRUE" ]; then
		verbose_msg "Adding signature..."

		case "$QDK_SIGNATURE" in
		gpg)
			local gpg_options="--detach-sign -o-" 
			[ -n "$QDK_GPG_NAME" ] && gpg_options="$gpg_options -u $QDK_GPG_NAME"
			is_quiet && gpg_options="$gpg_options --no-tty"
			debug_msg "$QDK_GPG_APP $gpg_options $QDK_QPKG_FILE >> ${QDK_QPKG_FILE}.sig"
			if $QDK_GPG_APP $gpg_options $QDK_QPKG_FILE >> ${QDK_QPKG_FILE}.sig; then
				add_qdk_area_begin
				add_qdk_area_signature ${QDK_QPKG_FILE}.sig
				add_qdk_area_end
				/bin/rm ${QDK_QPKG_FILE}.sig
			else
				warn_msg "$QDK_QPKG_FILE: no signature added"
			fi
			;;
		*)
			err_msg "$QDK_SIGNATURE: not supported signature type"
			;;
		esac
	fi
}

# Add QPKG tail (100 octets).
# [MODEL(10)|RESERVED(40])|FW_VERSION(10)|NAME(20)|VERSION(10)|FLAG(10)]
add_qpkg_tail(){
	local space_50="                                                  "
	local flag="QNAPQPKG  "

	verbose_msg "Adding tail data..."

	local max_qpkg_name_len=20
    local QPKG_NAME_SHORTER=$QPKG_NAME
	if (( $max_qpkg_name_len < ${#QPKG_NAME} )); then
		warn_msg "QPKG_NAME: the length of $QPKG_NAME must be less than or equal to $max_qpkg_name_len; name truncated."
		QPKG_NAME_SHORTER=$(/usr/bin/expr substr "$QPKG_NAME" 1 $max_qpkg_name_len)
	fi
	[ -z "$QDK_BUILD_MODEL" ] || _QPKG_MODEL="$QDK_BUILD_MODEL"
	pad_field _QPKG_MODEL
	_QPKG_NAME="$QPKG_NAME_SHORTER"
	pad_field _QPKG_NAME 20
	_QPKG_VERSION="$QPKG_VER"
	pad_field _QPKG_VERSION
	printf "${_QPKG_MODEL}${space_50}${_QPKG_NAME}${_QPKG_VERSION}${flag}" >> $QDK_QPKG_FILE
	debug_msg "${_QPKG_MODEL}${space_50}${_QPKG_NAME}${_QPKG_VERSION}${flag}"
}

# Add encryption.
add_qpkg_encryption(){
    verbose_msg "Adding QPKG checksum: $QDK_QPKG_FILE"
    /usr/bin/qpkg_encrypt $QDK_QPKG_FILE
}

create_qpkg(){
	# Model is _ARCH or empty for generic packages
	local arch="$1"
	local model="${arch:+_$arch}"
	local release="${QPKG_RELEASE:+-$QPKG_RELEASE}"

	msg "Creating QPKG package..."

	/bin/mkdir -m 755 -p "${QDK_BUILD_DIR:=build}" || err_msg "$QDK_BUILD_DIR: failed to create directory"

	QDK_QPKG_FILE=${QDK_QPKG_FILE:-${QPKG_NAME}_${QPKG_VER}${release}${model}.qpkg}
	verbose_msg "QPKG package name set to $QDK_QPKG_FILE"

	verbose_msg "Packaging optional extra data files..."
	# Include any optional extra data files.
	local extra_files="$(/bin/sed -n \
		-e '/^QDK_EXTRA_SRC_FILE/s/QDK_EXTRA_SRC_FILE="\(.*\)"/\1/p' \
		-e '/^QDK_EXTRA_FILE/s/QDK_EXTRA_FILE="\(.*\)"/\1/p' $QDK_QPKG_CONFIG)"
	[ -f tmp.$$/Packages.gz ] && extra_files="$extra_files tmp.$$/Packages.gz"
	for file in $extra_files
	do
		debug_msg "    $file"
		[ -f $file ] || err_msg "$file: no such file"
		[ -z "${file##/*}" ] || file="${QDK_ROOT_DIR:-.}/$file"
		/bin/tar rf tmp.$$/extra.tar -C "${file%/*}" "./${file##*/}"
	done

	add_qpkg_header "$arch"
	add_qpkg_content
	add_qpkg_signature
	add_qpkg_tail
	add_qpkg_encryption

	debug_msg "Copying $QDK_QPKG_FILE to $QDK_BUILD_DIR"
	/bin/cp -fp $QDK_QPKG_FILE $QDK_BUILD_DIR
	/bin/chmod 644 ${QDK_BUILD_DIR}/${QDK_QPKG_FILE}

	/bin/rm -f $QDK_QPKG_FILE
}

# Perform steps to build QPKG
build(){
	local arch="$1"
	local arch_dir="$2"

	/bin/mkdir -m 755 tmp.$$ || err_msg "failed to create directory for tar archives"

	if [ -f "$QDK_DATA_FILE" ]; then 
		verbose_msg "Using pre-packaged data archive: $QDK_DATA_FILE"
		case "$QDK_DATA_FILE" in
		*.tgz|*.tar.gz)
			debug_msg "Checking gzip compressed archive...."
			/bin/gunzip -c "$QDK_DATA_FILE" 2>/dev/null | /bin/tar t &>/dev/null || err_msg "$QDK_DATA_FILE: this does not look like a gzip compressed tar archive"
			QDK_COMPRESS_FILE="data.tar.gz"
			;;
		*.tbz2|*.tar.bz2)
			debug_msg "Checking bzip2 compressed archive...."
			/usr/bin/bunzip2 -c "$QDK_DATA_FILE" 2>/dev/null | /bin/tar t &>/dev/null || err_msg "$QDK_DATA_FILE: this does not look like a bzip2 compressed tar archive"
			QDK_COMPRESS_FILE="data.tar.bz2"
			;;
		*.tar.7z)
			debug_msg "Checking 7-zip compressed archive...."
			/usr/local/sbin/7z x -t7z -so "$QDK_DATA_FILE" 2>/dev/null | /bin/tar t &>/dev/null || err_msg "$QDK_DATA_FILE: this does not look like a 7-zip compressed tar archive"
			QDK_COMPRESS_FILE="data.tar.7z"
			;;
		*)
			err_msg "$QDK_DATA_FILE: this does not look like a compressed tar archive"
			;;
		esac
		debug_msg "$QDK_DATA_FILE renamed to $QDK_COMPRESS_FILE"
		/bin/cp "$QDK_DATA_FILE" tmp.$$/$QDK_COMPRESS_FILE
	else
		create_data_package "$arch" "$arch_dir"
	fi
	create_control_package
	create_packages_file
	create_qpkg "$arch" "$arch_dir"
	/bin/rm -fr tmp.$$
}

# Perform pre-build actions
pre_build(){
	# Clear QPKG package name before each build to be able to set a new default value
	# in create_qpkg unless the pre-build script has set a value.
	QDK_QPKG_FILE=

	if [ -f "$QDK_PRE_BUILD" ]; then
		verbose_msg "Running pre-build script: $QDK_PRE_BUILD"
		. "$QDK_PRE_BUILD" "$1" "$2" || err_msg "pre-build script returned error: $?"
	elif [ -n "$QDK_PRE_BUILD" ]; then
		warn_msg "$QDK_PRE_BUILD: no such file"
	fi

	[ -z "$QDK_BUILD_VERSION" ] || edit_qpkg_config QPKG_VER "$QDK_BUILD_VERSION"
	[ -z "$QDK_BUILD_RELEASE" ] || edit_qpkg_config QPKG_RELEASE "$QDK_BUILD_RELEASE"

	check_deprecated_definitions
}

# Perform post-build actions
post_build(){
	if [ -f "$QDK_POST_BUILD" ]; then
		verbose_msg "Running post-build script: $QDK_POST_BUILD"
		. "$QDK_POST_BUILD" "$1" "$2" || err_msg "post-build script returned error: $?"
	elif [ -n "$QDK_POST_BUILD" ]; then
		warn_msg "$QDK_POST_BUILD: no such file"
	fi
}

# Call specified setup script
call_setup(){
	if [ -f "$QDK_SETUP" ]; then
		verbose_msg "Running setup script: $QDK_SETUP"
		. "$QDK_SETUP" "" || err_msg "setup script returned error: $?"
	elif [ -n "$QDK_SETUP" ]; then
		warn_msg "$QDK_SETUP: no such file"
	fi
}

# Call specified teardown script.
call_teardown(){
	if [ -f "$QDK_TEARDOWN" ]; then
		verbose_msg "Running teardown script: $QDK_TEARDOWN"
		. "$QDK_TEARDOWN" "" || err_msg "teardown script returned error: $?"
	elif [ -n "$QDK_TEARDOWN" ]; then
		warn_msg "$QDK_TEARDOWN: no such file"
	fi
}

# Check for missing configuration files
check_missing_config_files(){
	if [ ! -f "$QDK_QPKG_CONFIG" ]; then
		echo "$QDK_QPKG_CONFIG: No such file" 1>&2
		exit 1
	fi
	if [ ! -f "$QDK_PACKAGE_ROUTINES" ]; then
		echo "$QDK_PACKAGE_ROUTINES: No such file" 1>&2
		exit 1
	fi
}

# Check definitions in QPKG configuration file.
check_mandatory_definitions(){
	# Source the QPKG configuration file to make all its fields available.
	. "$QDK_QPKG_CONFIG" || err_msg "$QDK_QPKG_CONFIG: corrupt configuration file"

	[ -n "$QPKG_AUTHOR" ] || err_msg "$QDK_QPKG_CONFIG: QPKG_AUTHOR must be assigned a value"
	[ -n "$QPKG_NAME" ] || err_msg "$QDK_QPKG_CONFIG: QPKG_NAME must be assigned a value"
	[ -n "$QPKG_VER" ] || err_msg "$QDK_QPKG_CONFIG: QPKG_VER must be assigned a value"
	[ -n "$QPKG_SERVICE_PROGRAM" ] || warn_msg "$QDK_QPKG_CONFIG: QPKG_SERVICE_PROGRAM is undefined"

}

# Handle max lenght and any space in name; anything after a space is removed.
truncate_qpkg_name(){
	if [ "$QPKG_NAME" != "${QPKG_NAME%% *}" ]; then
		warn_msg "QPKG_NAME: space is not allowed; name truncated."
		edit_qpkg_config QPKG_NAME "${QPKG_NAME%% *}"
	fi

	local max_qpkg_name_len=40
	if (( $max_qpkg_name_len < ${#QPKG_NAME} )); then
		warn_msg "QPKG_NAME: the length of $QPKG_NAME must be less than or equal to $max_qpkg_name_len; name truncated."
		QPKG_NAME=$(/usr/bin/expr substr "$QPKG_NAME" 1 $max_qpkg_name_len)
		edit_qpkg_config QPKG_NAME "$QPKG_NAME"
		
	fi
}

# Handle max lenght and any space in version; anything after a space is removed.
truncate_qpkg_version(){
	if [ "$QPKG_VER" != "${QPKG_VER%% *}" ]; then
		warn_msg "QPKG_VER: space is not allowed; value truncated."
		edit_qpkg_config QPKG_VER "${QPKG_VER%% *}"
	fi

	local max_qpkg_ver_len=10
	if (( $max_qpkg_ver_len < ${#QPKG_VER} )); then
		warn_msg "QPKG_VER: the length of $QPKG_VER must be less than or equal to $max_qpkg_ver_len; value truncated."
		QPKG_VER=$(/usr/bin/expr substr "$QPKG_VER" 1 $max_qpkg_ver_len)
		edit_qpkg_config QPKG_VER "$QPKG_VER"
	fi
}

# Assign default values if no values were included in QPKG configuration file
# nor provided in setup actions
assign_defaults(){
	if [ -z "$QDK_BUILD_ARCH" ]; then
		is_empty_dir "${QDK_DATA_DIR_X09:-arm-x09}" || add_arch "arm-x09"
		is_empty_dir "${QDK_DATA_DIR_X19:-arm-x19}" || add_arch "arm-x19"
		is_empty_dir "${QDK_DATA_DIR_X86:-x86}" || add_arch "x86"
		is_empty_dir "${QDK_DATA_DIR_X86_64:-x86_64}" || add_arch "x86_64"
	fi
	if [ -z "$QDK_BUILD_ARCH" ]; then
		if [ -f "$QDK_DATA_FILE" ] ||
		   ! is_empty_dir "${QDK_DATA_DIR_SHARED:-shared}"; then
			QDK_BUILD_ARCH="generic"
		fi
	fi
}

# Any actions to initialize build environment. After this function has been
# called all definitions in the qpkg.cfg file are available to other functions.
initialize_build_environment(){
	call_setup
	check_missing_config_files
	check_mandatory_definitions
	truncate_qpkg_name
	truncate_qpkg_version
	check_deprecated_definitions
	assign_defaults
}

# Traverse list of architectures and perform build.
traverse_and_build(){
	local arch=
	local arch_dir=
	local oldifs="$IFS"; IFS=,
	set ${QDK_BUILD_ARCH:-unknown}
	IFS="$oldifs"
	for arch
	do
		case "$arch" in
			arm-x09)
				arch_dir="${QDK_DATA_DIR_X09:-arm-x09}"
				;;
			arm-x19)
				arch_dir="${QDK_DATA_DIR_X19:-arm-x19}"
				;;
			x86)
				arch_dir="${QDK_DATA_DIR_X86:-x86}"
				;;
			x86_64)
				arch_dir="${QDK_DATA_DIR_X86_64:-x86_64}"
				;;
			generic)
				arch=""
				arch_dir=""
				;;
			?*)
				warn_msg "$arch: unsupported architecture"
				arch="unknown"
				;;
		esac
		if [ "$arch" != "unknown" ]; then
			pre_build "$arch" "$arch_dir"
			build "$arch" "$arch_dir"
			post_build "$arch" "$arch_dir"
		fi
	done
}

# Any actions to clean up after build
cleanup_after_build(){
	call_teardown
}


# Main build function.
build_qpkg(){
	# All build operation should be run in the QDK_ROOT_DIR directory (current
	# directory by default)
	cd "${QDK_ROOT_DIR:-.}" 2>/dev/null || err_msg "$QDK_ROOT_DIR: no such directory"

	initialize_build_environment

	if [ -n "$QDK_BUILD_ARCH" ]; then
		traverse_and_build
	else
		warn_msg "Nothing to build"
	fi

	cleanup_after_build
}

# Create directory with template build environment
create_env(){
	[ -n "$1" ] || err_msg "internal error: create_env called with no argument"
	local qpkg_name="$1"

	[ -d "$qpkg_name" ] && err_msg "$qpkg_name already exists"

	/bin/mkdir -m 755 -p "$qpkg_name" || err_msg "$qpkg_name: failed to create directory"

	/bin/cp -pfr "${QDK_TEMPLATE_DIR}"/* "$qpkg_name"

	local qpkg_cfg="${qpkg_name}/qpkg.cfg"
	edit_qpkg_config QPKG_AUTHOR "$(/usr/bin/whoami)" "$qpkg_cfg"
	edit_qpkg_config QPKG_NAME "$qpkg_name" "$qpkg_cfg"

	local init_script="${qpkg_name}/shared/${qpkg_name}.sh"
	/bin/mv ${qpkg_name}/shared/init.sh $init_script
	/bin/sed -i "s/QPKG_NAME=NAME/QPKG_NAME=\"$qpkg_name\"/" $init_script
	edit_qpkg_config QPKG_SERVICE_PROGRAM "${qpkg_name}.sh" "$qpkg_cfg"

	[ -z "$QDK_BUILD_VERSION" ] || edit_qpkg_config QPKG_VER "$QDK_BUILD_VERSION" "$qpkg_cfg"

	verbose_msg "Template QPKG build environment created in $qpkg_name directory"
}

# Extract files from specified QPKG.
extract_qpkg(){
	[ -n "$1" ] || err_msg "internal error: extract_qpkg called with no argument"
	local qpkg="$1"
	local dir="${2:-.}"
	[ -f $qpkg ] || err_msg "$qpkg: no such file"
	[ -d $dir ] || /bin/mkdir -p $dir

	local dd_quiet=
	local tar_quiet=
	is_quiet && tar_quiet=">/dev/null"
	is_verbose || dd_quiet="2>/dev/null"
	local extract_command="$(/bin/sed -n "1,/^exit 1/{
s!if=\${0} \(.* -C\) .*!$dd_quiet if=$qpkg \1 $dir $tar_quiet;!p
s!if=\${0} \(.* of.*\) ||.*!$dd_quiet if=$qpkg \1 $dd_quiet;!p
s/^script_len.*/&;/p
s/^offset.*/&;/p
/^exit 1/q
}" $qpkg)"
	[ -n "$extract_command" ] || err_msg "$qpkg: this does not look like a QPKG"
	extract_command="_EXTRACT_DIR=$dir; $extract_command"
	debug_msg "$extract_command"
	eval $extract_command
}

# Query information from specified QPKG.
query_qpkg(){
	[ -n "$1" ] || err_msg "internal error: query_qpkg called with no argument"
	local option="$1"
	local qpkg="$2"
	[ -f $qpkg ] || err_msg "$qpkg: no such file"
 	
	local dd_quiet=
	is_debug || dd_quiet="2>/dev/null"
	local output=
	if [ "$option" = "funcs" ]; then
		dd_command=$(/bin/sed -n "1,/^exit 1/{
s!if=\${0} \(.*\)\(xz\?\)v -C .*!$dd_quiet if=$qpkg \1\2 -O --no-anchor package_routines!p
s/^script_len.*/&;/p
/^exit 1/q
}" $qpkg)
		[ -n "$dd_command" ] || err_msg "$qpkg: this does not look like a QPKG"
		debug_msg "$dd_command"
		output="$(eval $dd_command)"
	else
		dd_command=$(/bin/sed -n "1,/^exit 1/{
s!if=\${0} \(.*\)\(xz\?\)v -C .*!$dd_quiet if=$qpkg \1\2 -O --no-anchor qpkg.cfg!p
s/^script_len.*/&;/p
/^exit 1/q
}" $qpkg)
		[ -n "$dd_command" ] || err_msg "$qpkg: this does not look like a QPKG"
		debug_msg "$dd_command"
		output="$(eval $dd_command | /bin/sed -n -e '/^QPKG_/p' -e '/^QDK_/p')"
	fi
 	
	case $option in
	dump)
		echo "$output"
		;;
	info)
		eval "$output"
		echo "Name     : $QPKG_NAME"
		echo "Version  : $QPKG_VER"
		echo "Packager : $QPKG_AUTHOR"
		echo "License  : ${QPKG_LICENSE:-Unknown}"
		echo "Summary  : $QPKG_SUMMARY"
		;;
	config)
		local qpkg_config=$(echo "$output" | /bin/sed -n '/^QPKG_CONFIG/s/QPKG_CONFIG="\(.*\)"/\1/p')
		[ -n "$qpkg_config" ] && echo "$qpkg_config"
		qpkg_config=$(echo "$output" | /bin/sed -n '/^QPKG_CONFIG_DIR/s/QPKG_CONFIG_DIR="\(.*\)"/\1/p')
		[ -n "$qpkg_config" ] && echo "$qpkg_config (using obsolete QPKG_CONFIG_DIR)"
		;;
	funcs)
		echo "$output"
		;;
	require)
		eval "$output"
		[ -z "$QPKG_REQUIRE" ] || echo "$QPKG_REQUIRE" | /bin/sed 's/ *, */\n/g'
		;;
	conflict)
		eval "$output"
		[ -z "$QPKG_CONFLICT" ] || echo "$QPKG_CONFLICT" | /bin/sed 's/ *, */\n/g'
		;;
	*)
		;;
	esac
}

# Verify signature
verify_qpkg(){
	[ -n "$1" ] || err_msg "internal error: verify_qpkg called with no argument"
	local qpkg="$1"
	[ -f $qpkg ] || err_msg "$qpkg: no such file"

	local data_size=
	local sign_pos=
	local sign_len=
	data_size=$(get_qdk_area_pos $qpkg) || exit 0
	sign_pos=$(get_signature_pos $qpkg) || exit 0
	sign_len=$(get_signature_len $qpkg) || exit 0

	local gpg_options="--verify --no-default-keyring --keyring $QDK_GPG_PUBKEYRING"
	is_verbose || gpg_options="$gpg_options 2>/dev/null"
	local gpg_cmd="$QDK_GPG_APP $gpg_options \
		<(/bin/dd if=$qpkg bs=1 skip=$sign_pos count=$sign_len 2>/dev/null) \
		<(/bin/dd if=$qpkg bs=$data_size count=1 2>/dev/null)"
	debug_msg "$gpg_cmd"
	if eval $gpg_cmd; then
		msg "Verification OK"
	else
		err_msg "Verification Failure"
	fi
}

# Re-sign QPKG.
add_sign_qpkg(){
	[ -n "$1" ] || err_msg "internal error: add_sign_qpkg called with no argument"
	local qpkg="$1"
	[ -f $qpkg ] || err_msg "$qpkg: no such file"

	case "$QDK_SIGNATURE" in
	gpg)
		verbose_msg "Find and remove any existing signature..."

		local data_size=
		if data_size=$(get_content_size $qpkg); then
			local sign_pos=
			if sign_pos=$(get_signature_pos $qpkg); then
				local sign_len=$(get_signature_len $qpkg)
				debug_msg "Signature located at position $sign_pos with size $sign_len"
				verbose_msg "Existing signature removed"
			fi
		fi
		[ -n "$data_size" ] || err_msg "$qpkg: not QDK 2.0 or later"

		dd_cmd="/bin/dd if=$qpkg bs=$data_size count=1 2>/dev/null > ${qpkg}.$$"
		debug_msg "$dd_cmd"
		eval "$dd_cmd"

		verbose_msg "Generate and add new signature..."
		local gpg_options="--detach-sign -o-" 
		[ -n "$QDK_GPG_NAME" ] && gpg_options="$gpg_options -u $QDK_GPG_NAME"
		is_quiet && gpg_options="$gpg_options --no-tty"
		gpg_cmd="$QDK_GPG_APP $gpg_options ${qpkg}.$$ >> ${qpkg}.sig"
		debug_msg "$gpg_cmd"
		eval $gpg_cmd || warn_msg "${qpkg##*/}: no signature added"

		add_qdk_area_begin ${qpkg}.$$
		add_qdk_area_signature ${qpkg}.sig ${qpkg}.$$
		add_qdk_area_end ${qpkg}.$$

		verbose_msg "Add tail data..."
		printf "$(/usr/bin/tail -c$TAIL_DATA_LEN $qpkg)" >> ${qpkg}.$$
		verbose_msg "Adding QPKG checksum: $(/sbin/qpkg --encrypt ${qpkg}.$$)"
		/bin/rm ${qpkg}.sig
		/bin/mv ${qpkg}.$$ $qpkg
		;;
	*)
		err_msg "$QDK_SIGNATURE: not supported signature type"
		;;
	esac
}

# Import public key
import_key(){
	[ -n "$1" ] || err_msg "internal error: import_key called with no argument"
	local key="$1"
	[ -f $key ] || err_msg "$key: no such file"
	gpg_cmd="$QDK_GPG_APP --no-default-keyring --keyring $QDK_GPG_PUBKEYRING --import $key"
	is_quiet && gpg_cmd="$gpg_cmd 2>/dev/null"
	debug_msg "$gpg_cmd"
	eval $gpg_cmd
}

# Remove public key
remove_key(){
	[ -n "$1" ] || err_msg "internal error: remove_key called with no argument"
	local key="$1"
	gpg_cmd="$QDK_GPG_APP --no-default-keyring --keyring $QDK_GPG_PUBKEYRING --delete-keys $key 2>/dev/null"
	debug_msg "$gpg_cmd"
	eval $gpg_cmd
}

# List keys in public keyring
list_keys(){
	gpg_cmd="$QDK_GPG_APP --no-default-keyring --keyring $QDK_GPG_PUBKEYRING --list-keys"
	debug_msg "$gpg_cmd"
	eval $gpg_cmd
}


# Add definitions from specified section
add_qdk_definitions(){
	[ -n "$1" ] || err_msg "internal error: add_qdk_definitions called with no argument"
	local section="$1"

	if [ -f "$QDK_USER_CONFIG_FILE" ]; then
		local section_defs=$(/bin/sed -n "/\[$section\]/,/[[]/p" "$QDK_USER_CONFIG_FILE" | /bin/sed -e '/^\[/d' -e '/^$/d')
		[ -n "$section_defs" ] && eval "$section_defs"
	fi
}

usage(){
	/bin/cat <<EOF
usage: $(/usr/bin/basename $0) [--extract QPKG [DIR]] [--create-env NAME] [-s|--section SECTION]
	[--root ROOT_DIR] [--build-arch ARCH] [--build-version VERSION]
	[--build-model MODEL] [--build-dir BUILD_DIR] [--force-config]
	[--setup SCRIPT] [--teardown SCRIPT] [--pre-build SCRIPT]
	[--post-build SCRIPT] [--exclude PATTERN] [--exclude-from FILE]
	[--gzip|--bzip2|--7zip|--xz {amd64|armhf}] [--sign] [--gpg-name ID] [--verify QPKG]
	[--add-sign QPKG] [--import-key KEY] [--remove-key ID] [--list-keys]
	[--query OPTION QPKG] [-v|--verbose] [-q|--quiet] [--strict]
	[-?|-h|--help] [--usage] [-V|--version]
EOF
	exit 0
}

help(){
	/bin/cat <<EOF
usage: $(/usr/bin/basename $0) [--extract QPKG [DIR]] [--create-env NAME] [-s|--section SECTION]
	[--root ROOT_DIR] [--build-arch ARCH] [--build-version VERSION]
	[--build-number NUMBER] [--build-model MODEL] [--build-dir BUILD_DIR]
	[--force-config] [--setup SCRIPT] [--teardown SCRIPT]
	[--pre-build SCRIPT] [--post-build SCRIPT] [--exclude PATTERN]
	[--exclude-from FILE] [--gzip|--bzip2|--7zip] [--sign] [--gpg-name ID]
	[--verify QPKG] [--add-sign QPKG] [--import-key KEY] [--remove-key ID]
	[--list-keys] [--query OPTION QPKG] [-v|--verbose] [-q|--quiet]
	[--strict] [-?|-h|--help] [--usage] [-V|--version]

-s
--section SECTION
	Add SECTION to the list of searched sections in the configuration file.
	A section is a named set of definitions. By default, the DEFAULT section
	will be searched and then any sections specified on the command line.
--root ROOT_DIR
	Use files and meta-data in ROOT_DIR when the QPKG is built (default is
	the current directory, '.').
--build-version VERSION
	Use given version when QPKG is built (also updates the QPKG_VER
	definition in qpkg.cfg).
--build-number NUMBER
	Use given build number when QPKG is built.
--build-model MODEL
	Include check for given model in the QPKG package.
--build-arch ARCH
	Build QPKG for specified ARCH (supported values: arm-x09, arm-x19, x86,
	and x86_64). Only one architecture per option, but you can repeat the
	option on the command line to add multiple architectures.
--build-dir BUILD_DIR
	Place built QPKG in BUILD_DIR. If a full path is not specified then it
	is relative to the ROOT_DIR (default is ROOT_DIR/build).
--setup SCRIPT
	Run specified script to setup build environment. Called once before
	build process is initiated.
--teardown SCRIPT
	Run specified script to cleanup after all builds are finished. Called
	once after all builds are completed.
--pre-build SCRIPT
	Run specified script before the build process is started. Called before
	each and every build. First argument contains the architecture (one of
	arm-x09, arm-x19, x86, and x86_64) and the second argument contains the
	location of the architecture specific code. For the generic build the
	arguments are empty.
--post-build SCRIPT
	Run specified script after the build process is finished. Called after
	each and every build. First argument contains the architecture (one of
	arm-x09, arm-x19, x86, and x86_64) and the second argument contains the
	location of the architecture specific code. For the generic build the
	arguments are empty.
--create-env NAME
	Create a template build environment in the current directory
	for a QPKG named NAME.
--extract QPKG [DIR]
	Extract archive of files and meta-data from QPKG to DIR (default is
	current directory).
--exclude PATTERN
	Do not include files matching PATTERN in data package. This option is
	passed on to rsync and follows the same rules as rsync's --exclude
	option. Only one exclude pattern per option, but you can repeat the
	option on the command line to add multiple patterns.
--exclude-from FILE
	Related to --exclude, but specifies a FILE that contains exclude
	patterns (one per line). This option is passed on to rsync and follows
	the same rules as rsync's --exclude-from option.
--strict
	Treat warnings as errors.
--force-config
	Ignore missing configuration files specified in QPKG_CONFIG.
--gzip
	Compress QPKG content using gzip (this is the default compression when
	no compression option is specified.)
--bzip2
	Compress QPKG content using bzip2.
--7zip
	Compress QPKG content using 7-zip.
--query OPTION QPKG
	Retrieve information from QPKG. Available options:
	  dump		dump settings from qpkg.cfg
	  info		summary of settings in qpkg.cfg
	  config	list configuration files
	  require	list required packages
	  conflict	list conflicting packages
	  funcs		output package specific functions
--sign
	Generate and insert digital signature to QPKG. By default the first key
	in the secret keyring is used.
--gpg-name ID
	Use specified user ID to sign QPKG.
--verify QPKG
	Verify digital signature assigned to QPKG.
--add-sign QPKG
	Generate and insert digital signature to QPKG, replacing any existing
	signature.
--import-key KEY
	Import ASCII armored key to public keyring.
--list-keys
	Show keys in public keyring.
--remove-key ID
	Remove key with specified ID from public keyring.
-?
-h
--help
	Show this help message.
--usage
	Display brief usage information.
-q
--quiet
	Silent mode. Do not write anything to standard output. Normally only
	error messages will be displayed.
-v
--verbose
	Verbose mode. Multiple options increase the verbosity. The maximum is 3.
-V
--version
	Print a single line containing the version number of QDK.
EOF
	exit 0
}

version(){
	echo "$(/usr/bin/basename $0) $QDK_VERSION"
	exit 0
}

main(){
	QDK_QPKG_CONFIG="${QDK_QPKG_CONFIG:-qpkg.cfg}"
	QDK_PACKAGE_ROUTINES="${QDK_PACKAGE_ROUTINES:-package_routines}"

	QDK_COMPRESS_METHOD="${QDK_COMPRESS_METHOD:-gzip}"
	QDK_CONTROL_FILE="${QDK_CONTROL_FILE:-control.tar}"
	QDK_COMPRESS_FILE="${QDK_COMPRESS_FILE:-data.tar.gz}"
	QDK_GPG_PUBKEYRING="${QDK_GPG_PUBKEYRING:-/etc/config/qpkg.gpg}"

	[ -n "$QDK_GPG_KEYPATH" ] && export GNUPGHOME="$QDK_GPG_KEYPATH"

	QDK_VERBOSE=${QDK_VERBOSE:-$NORMAL}

	sanity_check_qdk_environment

	check_deprecated_definitions

	local qbuild_usage=
	local qbuild_help=
	local qbuild_quiet=
	local qbuild_version=
	local qbuild_qpkg_name=
	local qbuild_extract_file=
	local qbuild_import_key=
	local qbuild_remove_key=
	local qbuild_verify_file=
	local qbuild_add_sign_file=
	local qbuild_sign=
	local qbuild_list_keys=
	while  (( 0 < $# ))
	do
		case "$1" in
		--usage)	qbuild_usage=TRUE ;;
		--help|-h|-\?)	qbuild_help=TRUE ;;
		--version|-V)	qbuild_version=TRUE ;;
		--quiet|-q)	qbuild_quiet=TRUE ;;
		--verbose|-v)	QDK_VERBOSE=$(($QDK_VERBOSE + 1));;
		--strict)	QDK_STRICT=TRUE ;;
		--force-config)	QDK_FORCE_CONFIG=TRUE ;;
		--7zip)		QDK_COMPRESS_METHOD="7zip"
				;;
		--gzip)		QDK_COMPRESS_METHOD="gzip"
				;;
		--bzip2)	QDK_COMPRESS_METHOD="bzip2"
				;;
		--xz)	QDK_COMPRESS_METHOD="xz"
				[ -n "$QDK_COMPRESS_METHOD" ] || err_msg "--xz: no arch"
                QDK_XZ_ARCH=$2
				shift
				;;
		--create-env)	qbuild_qpkg_name="$2"
				[ -n "$qbuild_qpkg_name" ] || err_msg "--create-env: no name"
				shift
				;;
		--setup)	QDK_SETUP="$2"
				[ -n "$QDK_SETUP" ] || err_msg "--setup: no script"
				shift
				;;
		--teardown)	QDK_TEARDOWN="$2"
				[ -n "$QDK_TEARDOWN" ] || err_msg "--teardown: no script"
				shift
				;;
		--pre-build)	QDK_PRE_BUILD="$2"
				[ -n "$QDK_PRE_BUILD" ] || err_msg "--pre-build: no script"
				shift
				;;
		--post-build)	QDK_POST_BUILD="$2"
				[ -n "$QDK_POST_BUILD" ] || err_msg "--post-build: no script"
				shift
				;;
		--build-dir) 	QDK_BUILD_DIR="$2"
				[ -n "$QDK_BUILD_DIR" ] || err_msg "--build-dir: no directory"
				shift
				;;
		--build-version) QDK_BUILD_VERSION="$2"
				[ -n "$QDK_BUILD_VERSION" ] || err_msg "--build-version: no version"
				shift
				;;
		--build-number) QDK_BUILD_RELEASE="$2"
				[ -n "$QDK_BUILD_RELEASE" ] || err_msg "--build-number: no number"
				shift
				;;
		--build-arch)	local arch="$2"
				[ -n "$arch" ] || err_msg "--build-arch: no architecture"
				add_arch "$arch"
				shift
				;;
		--build-model)	QDK_BUILD_MODEL="$2"
				[ -n "$QDK_BUILD_MODEL" ] || err_msg "--build-model: no model"
				shift
				;;
		--root)		QDK_ROOT_DIR="$2"
				[ -n "$QDK_ROOT_DIR" ] || err_msg "--root: no directory"
				shift
				;;
		--extract)	qbuild_extract_file="$2"
				qbuild_extract_dir="$3"
				[ -n "$qbuild_extract_file" ] || err_msg "--extract: no file"
				shift
				;;
		--exclude)	local rsync_pattern="$2"
				[ -n "$rsync_pattern" ] || err_msg "--exclude: no pattern"
				QDK_RSYNC_EXCLUDE="$QDK_RSYNC_EXCLUDE --exclude=$rsync_pattern"
				shift
				;;
		--exclude-from)	local rsync_file="$2"
				[ -n "$rsync_file" ] || err_msg "--exclude-from: no file"
				QDK_RSYNC_EXCLUDE_FROM="--exclude-from=$rsync_file"
				shift
				;;
		--section|-s)	local section="$2"
				[ -n "$section" ] || err_msg "--section: no section"
				add_qdk_definitions "$section"
				shift
				;;
		--sign)		qbuild_sign=TRUE ;;
		--gpg-name)	QDK_GPG_NAME="$2"
				[ -n "$QDK_GPG_NAME" ] || err_msg "--gpg-name: no name"
				QDK_SIGNATURE="gpg"
				QDK_SIGN="TRUE"
				shift
				;;
		--verify)	qbuild_verify_file="$2"
				[ -n "$qbuild_verify_file" ] || err_msg "--verify: no file"
				shift
				;;
		--add-sign)	qbuild_add_sign_file="$2"
				[ -n "$qbuild_add_sign_file" ] || err_msg "$1: no file"
				shift
				;;
		--import-key)	qbuild_import_key="$2"
				[ -n "$qbuild_import_key" ] || err_msg "--import-key: no file"
				shift
				;;
		--remove-key)	qbuild_remove_key="$2"
				[ -n "$qbuild_remove_key" ] || err_msg "--remove-key: no name"
				shift
				;;
		--list-keys)	qbuild_list_keys=TRUE ;;
		--query)	qbuild_query_option="$2"
				qbuild_query_qpkg="$3"
				[ -n "$qbuild_query_qpkg" ] || err_msg "--query: missing argument"
				shift
				;;
		-*)		qbuild_usage=TRUE ;;
		esac
		shift
	done

	[ -z "$qbuild_quiet" ] || QDK_VERBOSE=$QUIET
	# Check for extra verbose debug messages.
	(( $QDK_VERBOSE <= $DEBUG )) || set -x

	[ -n "$qbuild_version" ] && version
	[ -n "$qbuild_usage" ] && usage
	[ -n "$qbuild_help" ] && help

	QDK_STRICT=${QDK_STRICT:-FALSE}
	QDK_FORCE_CONFIG=${QDK_FORCE_CONFIG:-FALSE}

	if [ -n "$qbuild_sign" ]; then
		[ -n "$QDK_SIGNATURE" ] || err_msg "--sign: QDK_SIGNATURE must be defined"
		case "$QDK_SIGNATURE" in
		gpg)
			QDK_SIGN="TRUE"
			;;
		*)
			err_msg "$QDK_SIGNATURE: not supported signature type"
			;;
		esac
	fi
	if [ "$QDK_SIGN" = "TRUE" ] || [ -n "$qbuild_verify_file" ] ||
	   [ -n "$qbuild_add_sign_file" ] || [ -n "$qbuild_import_key" ] ||
	   [ -n "$qbuild_remove_key" ] || [ -n "$qbuild_list_keys" ]; then
		QDK_GPG_APP="${QDK_GPG_APP:-$(command -v gpg2)}"
		[ -x "$QDK_GPG_APP" ] || err_msg "${QDK_GPG_APP:-gpg2}: command not found"
	fi

	if [ -n "$qbuild_qpkg_name" ]; then 
		create_env "$qbuild_qpkg_name"
	elif [ -n "$qbuild_extract_file" ]; then 
		extract_qpkg "$qbuild_extract_file" "$qbuild_extract_dir"
	elif [ -n "$qbuild_verify_file" ]; then 
		verify_qpkg "$qbuild_verify_file"
	elif [ -n "$qbuild_add_sign_file" ]; then 
		add_sign_qpkg "$qbuild_add_sign_file"
	elif [ -n "$qbuild_import_key" ]; then 
		import_key "$qbuild_import_key"
	elif [ -n "$qbuild_remove_key" ]; then 
		remove_key "$qbuild_remove_key"
	elif [ -n "$qbuild_list_keys" ]; then 
		list_keys
	elif [ -n "$qbuild_query_qpkg" ]; then
		query_qpkg "$qbuild_query_option" "$qbuild_query_qpkg"
	else
		build_qpkg
	fi
}

# System-wide definitions
. /usr/share/qdk2/QDK/qdk.conf

# User definitions
QDK_USER_CONFIG_FILE="${QDK_USER_CONFIG_FILE:-$HOME/.qdkrc}"
add_qdk_definitions DEFAULT

main "$@"
